{
    "version": "https://jsonfeed.org/version/1",
    "title": "服务端技术",
    "home_page_url": "https://pengyumo.com",
    "feed_url": "https://pengyumo.com/feed.json",
    "description": "记录生活、记录成长",
    "icon": "https://cdn.jsdelivr.net/gh/zhixinpeng/storage/img/avatar_300x300.png",
    "author": {
        "name": "服务端技术",
        "url": "https://pengyumo.com"
    },
    "items": [
        {
            "content_html": "<p>[[toc]]</p>\n<p>今天想聊一聊 Vue 3.0 的 script-setup，以及目前三个很少被提及到的 API —— defineProps 、 defineEmit 和 useContext。</p>\n<p>截止到我撰写本文，它们在 Vue 3.0 的官网都还没有相关的用法说明，<strong>因为目前还属于实验性的新特性</strong>，什么时候会并入正式轨道，时间上还不清楚，但事实上在项目里已经可以使用起来了，自己体验了一段时间，真的爽！！！</p>\n<p>目前在社区讨论方面，script-setup 的知名度还是可以的，但是对应的另外 3 个专属 API 还是比较默默无名，这说明什么？看热闹的人多，实际体验的人少。</p>\n<p>很多人应该还只是处于单纯知道 script-setup 对于原来的 setup 起到什么样的便利性，但一旦哪天真的想用起来，会发现不知道 props 怎么用，不知道 emit 怎么用，用法完全变了，还一时半会搜不到文档，关键时刻被卡住（这一点在 stackoverflow 上的问题咨询体现的比较明显），这也是我想写一写这篇文章的目的，提前科普这几个新特性。</p>\n<blockquote>\n<p><br>在阅读这篇文章之前，需要对 Vue 3.0 的 setup 函数有一定的了解，如果还处于完全没有接触过的阶段，请先抽点时间阅读  <a href=\"https://vue3.chengpeiquan.com/component.html\">单组件的编写 - Vue3.0学习教程与实战案例</a> 。<br><br>\n<br>另外，根据 vue-next 的 <a href=\"https://github.com/vuejs/vue-next/blob/master/CHANGELOG.md\">changelog</a> ，记得先把 vue 和 @vue/compiler-sfc 这两个依赖都升级到 v3.0.4 版本或以上（这两个依赖必须保持同样的版本号，我自己是在目前最新的 v3.0.7 版本下跑通了所有 API，版本太低会报错，因为旧版本还没有包含更新的内容）<br></p>\n</blockquote>\n<p>本文会划分为四个部分：</p>\n<ol>\n<li>\n<p>讲一讲 script-setup</p>\n</li>\n<li>\n<p>回顾一下 props 和 emits</p>\n</li>\n<li>\n<p>讲一讲 defineProps 和 defineEmit</p>\n</li>\n<li>\n<p>讲一讲 useContext</p>\n</li>\n</ol>\n<p>通过这几个维度来讲一讲这个便捷版 setup 的用法和需要注意的问题。</p>\n<h2>什么是 script-setup</h2>\n<p>在 Vue 3.0 的 .vue 组件里，标准的 setup 用法，默认的 SFC 规范里（注：SFC，即 Single-File Component，<code>.vue</code> 单组件）要求，在 setup 里面定义的数据如果需要在 template 使用，都需要 return 出来，如果你使用的是 TypeScript ，还需要借助 defineComponent 来帮助你对类型的自动推导。</p>\n<pre><code class=\"language-html\">&lt;!-- 标准组件格式 --&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  setup () {\n    \n    // 要给 template 用的数据需要 return 出来才可以\n    return {}\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<p>关于 setup 和 defineComponent 的说明和用法，可以查阅我以前写的 <a href=\"https://vue3.chengpeiquan.com/component.html#%E5%85%A8%E6%96%B0%E7%9A%84-setup-%E5%87%BD%E6%95%B0-new\">全新的 setup 函数</a> 。</p>\n<p>而 script-setup 的推出是为了让熟悉 3.0 的用户可以更高效率的开发组件，减少一些心智负担，只需要给 script 标签添加一个 setup 属性，那么整个 script 就直接会变成 setup 函数，所有顶级变量、函数，均会自动暴露给模板使用（无需再一个个 return 了）。</p>\n<p>Vue 会通过单组件编译器，在编译的时候将其处理回标准组件，所以目前这个方案只适合用 <code>.vue</code> 文件写的工程化项目。</p>\n<pre><code class=\"language-html\">&lt;!-- 使用 script-setup 格式 --&gt;\n&lt;script setup lang=&quot;ts&quot;&gt;\n  // ...\n&lt;/script&gt;\n</code></pre>\n<p>对，就是这样，代码量瞬间大幅度减少……</p>\n<p>而组件的挂载，在原来的写法是需要 import 后再放到 components 里才能够启用：</p>\n<pre><code class=\"language-html\">&lt;!-- 标准组件格式 --&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { defineComponent } from 'vue'\n\n// 需要先导入组件\nimport Header from '@cp/Header.vue'\n\nexport default defineComponent({\n  // 需要通过 components 才能启用子组件\n  components: {\n    Header\n  },\n  setup () {\n    // ...\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<p>在 script-setup 模式下，只需要导入组件即可，编译器会自动识别并启用。</p>\n<pre><code class=\"language-html\">&lt;!-- 使用 script-setup 格式 --&gt;\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport Header from '@cp/Header.vue'\n&lt;/script&gt;\n</code></pre>\n<p>其他的变量、函数，以及 onMounted 等生命周期，还有像 watch 、 computed 等监听/计算功能，都跟原来一样定义就可以了，没有太大的区别。</p>\n<p>区别比较大的还是 props / emits 的定义和调用，由于在 export 组件的时候没有了对象式选项，setup 也没有了函数入参，标准组件的用法无法直接迁移到 script-setup ，因此针对该模式， Vue 3.0 单独推出了三个专属的 API：defineProps 、 defineEmit 和 useContext 。</p>\n<p>在了解它俩之前，想先给大家回顾下什么是 props 和 emits ，已经了解熟悉它们的同学可以直接跳去本文 <a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-defineprops-%E5%92%8C-defineemit\">什么是 defineProps 和 defineEmit</a> 部分。</p>\n<h2>什么是 props 和 emits</h2>\n<p>通常我们为了避免一个页面（父组件）写的又长又臭，会根据布局/功能模块，把页面切割为不同的小模块（子组件），最后再像搭积木一样把它搭回来，完成我们的作品，我画了一个示例图，就是下面这样子：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2021/01/20210303180727.png\" alt=\"每一个“积木”都是一个组件\"></p>\n<p>比如上面是一个 home.vue , 它包含了 Header.vue / Footer.vue / Content.vue / Sidebar.vue 等子组件，如果此时页面上有一个公共的数据，有多个子组件都需要用到的话，就没有必要在诸如 Content / Sidebar 里分别获取或者定义了，而是在父组件 home 里面处理好后，传递给子组件使用。</p>\n<p>props 就是在这种情况下用于父组件向子组件传递数据，而 emits 则是让子组件可以向父组件发起通信。</p>\n<p>在 home.vue 定义了一个数据和方法之后，传递给子组件 Content.vue ：</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;Content\n    :name=&quot;name&quot;\n    @change-name=&quot;changeName&quot;\n  /&gt;\n&lt;/template&gt;\n\n&lt;script lang=&quot;ts&quot;&gt;\nimport { defineComponent, ref } from 'vue'\nimport Content from '@cp/Content.vue'\n\nexport default defineComponent({\n  components: {\n    Content\n  },\n  setup () {\n    const name = ref&lt;string&gt;('Petter');\n\n    const changeName = (): void =&gt; {\n      name.value = 'Tom';\n    }\n\n    return {\n      name,\n      changeName\n    }\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<p>子组件通过 prop 来接收 name 数据，通过 emit 来接收和提交名字的变更方法 changeName ：</p>\n<pre><code class=\"language-html\">&lt;script lang=&quot;ts&quot;&gt;\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  props: [ 'name' ],\n  emits: [ 'changeName' ],\n  setup (props, { emit }) {\n\n    setTimeout(() =&gt; {\n      emit('changeName', 'Tom');\n    }, 1000);\n    \n  }\n})\n&lt;/script&gt;\n</code></pre>\n<p>当然，这里不是想说 props 和 emits 怎么用，关于 props 和 emits 的定义和具体用法，在 <a href=\"https://vue3.chengpeiquan.com/communication.html#props-emits\">props / emits</a> 一节已有详细的总结和案例，这篇文章里就不再展开更多说明啦！</p>\n<h2>什么是 defineProps 和 defineEmit</h2>\n<p>回来说这两个 API ，顾名思义， defineProps 一看就知道是用来定义 props 的，而 defineEmit 则是用来定义 emits 的，那么它俩跟上面提到的 props / emits 有什么区别？</p>\n<p>在你的项目 <code>node_modules\\@vue\\runtime-core\\dist\\runtime-core.d.ts</code> 里，有一段针对该 API 的注释（不要问我怎么找到这里的，我只能跟你说我用的 VSCode …）：</p>\n<pre><code class=\"language-ts\">/**\n * Compile-time-only helper used for declaring props inside `&lt;script setup&gt;`.\n * This is stripped away in the compiled code and should never be actually\n * called at runtime.\n */\n</code></pre>\n<p>很清晰的解释了它们的使用限制，只能用于 script-setup 。</p>\n<p>那么我们来看下用便捷版 setup 写法之后，父组件长什么样：</p>\n<pre><code class=\"language-html\">&lt;!-- 这是父组件，template 下发了 prop 和 emit --&gt;\n&lt;template&gt;\n  &lt;Child\n    :name=&quot;name&quot;\n    @change-name=&quot;changeName&quot;\n  /&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport { ref } from 'vue'\nimport Child from '@cp/Child.vue'\n\nconst name = ref&lt;string&gt;('Petter');\n\nconst changeName = (): void =&gt; {\n  name.value = 'Tom';\n}\n&lt;/script&gt;\n</code></pre>\n<p>有没有瞬间清爽百倍的感觉！！！</p>\n<p>在 script-setup 的写法里，所有数据都是默认 <code>return</code> 的，子组件也无需通过 <code>components</code> 选项进行挂载了，默认导入即生效，在编码过程中，可以大大的提高开发效率。</p>\n<blockquote>\n<p>所以疑问就来了，父组件是爽了，那么子组件呢？整个 script 都变成了一个大的 setup function ，没有了组件选项，也没有了 setup 入参，如何获取父组件传下来的 props 和 emits 呢？</p>\n</blockquote>\n<p>所以，这两个新的 API ，就是在 script-setup 里帮助子组件拿到父级传过来的 props 和 emits 。</p>\n<blockquote>\n<p>注：以下所有的 JS / TS 部分，如果没有特别说明，都是指写在 <code>&lt;script setup&gt;</code> 里</p>\n</blockquote>\n<h2>defineProps</h2>\n<p>defineProps 是一个方法，内部返回一个对象，也就是挂载到这个组件上的所有 props ，它和普通的 props 用法一样，如果不指定为 prop， 则传下来的属性会被放到 attrs 那边去。</p>\n<h3>基础用法</h3>\n<p>所以，如果只是单纯在 template 里使用，那么其实就这么简单定义就可以了：</p>\n<pre><code class=\"language-js\">import { defineProps } from 'vue'\n\ndefineProps([\n  'name',\n  'userInfo',\n  'tags'\n])\n</code></pre>\n<p>使用 <code>string[]</code> 数组作为入参，把 prop 的名称作为数组的 item 传给 defineProps 就可以了。</p>\n<blockquote>\n<p>记得从 vue 导入 defineProps 噢，下面的代码就不重复 import 啦！！！</p>\n</blockquote>\n<p>如果 script 里的方法要拿到 props 的值，你也可以使用字面量定义：</p>\n<pre><code class=\"language-ts\">const props = defineProps([\n  'name',\n  'userInfo',\n  'tags'\n])\n\nconsole.log(props.name);\n</code></pre>\n<p>但在作为一个 Vue 老玩家，都清楚不显性的指定 prop 类型的话，很容易在协作中引起程序报错，那么应该如何对每个 prop 进行类型检查呢？</p>\n<p>有两种方式来处理类型定义。</p>\n<h3>通过构造函数进行检查</h3>\n<p>这是第一种方式：使用 JavaScript 原生构造函数进行类型规定。</p>\n<p>也就是跟我们平时定义 prop 类型时一样， Vue 会通过 instanceof 来进行 <a href=\"https://v3.cn.vuejs.org/guide/component-props.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5\">类型检查</a> 。</p>\n<p>使用这种方法，需要通过一个 “对象” 入参来传递给 defineProps，比如：</p>\n<pre><code class=\"language-ts\">defineProps({\n  name: String,\n  userInfo: Object,\n  tags: Array\n});\n</code></pre>\n<p>所有原来 props 具备的校验机制，都可以适用，比如你除了要限制类型外，还想指定 name 是可选，并且带有一个默认值：</p>\n<pre><code class=\"language-ts\">defineProps({\n  name: {\n    type: String,\n    required: false,\n    default: 'Petter'\n  },\n  userInfo: Object,\n  tags: Array\n});\n</code></pre>\n<p>更多的 props 校验机制，可以点击 <a href=\"https://vue3.chengpeiquan.com/communication.html#%E5%B8%A6%E6%9C%89%E7%B1%BB%E5%9E%8B%E9%99%90%E5%88%B6%E7%9A%84-props\">带有类型限制的 props</a> 和 <a href=\"https://vue3.chengpeiquan.com/communication.html#%E5%8F%AF%E9%80%89%E4%BB%A5%E5%8F%8A%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84-props\">可选以及带有默认值的 props</a> 了解更多。</p>\n<h3>使用类型注解进行检查</h3>\n<p>这是第二种方式：使用 TypeScript 的类型注解。</p>\n<p>和 ref 等 API 的用法一样，defineProps 也是可以使用尖括号 &lt;&gt; 来包裹类型定义，紧跟在 API 后面，另外，由于 defineProps 返回的是一个对象（因为 props 本身是一个对象），所以尖括号里面的类型还要用大括号包裹，通过 <code>key: value</code> 的键值对形式表示，如：</p>\n<pre><code class=\"language-ts\">defineProps&lt;{ name: string }&gt;();\n</code></pre>\n<p>注意到了吗？这里使用的类型，和第一种方法提到的指定类型时是不一样的，在这里，不再使用构造函数校验，而是需要遵循使用 TypeScript 的类型，比如字符串是 string，而不是 String。</p>\n<p>如果有多个 prop ，就跟写 interface 一样：</p>\n<pre><code class=\"language-ts\">defineProps&lt;{\n  name: string;\n  phoneNumber: number;\n  userInfo: object;\n  tags: string[];\n}&gt;();\n</code></pre>\n<p>其中，举例里的 userInfo 是一个对象，你可以简单的指定为 object，也可以先定义好它对应的类型，再进行指定：</p>\n<pre><code class=\"language-ts\">interface UserInfo {\n  id: number;\n  age: number;\n}\n\ndefineProps&lt;{\n  name: string;\n  userInfo: UserInfo;\n}&gt;();\n</code></pre>\n<p>如果你想对某个数据设置为可选，也是遵循 TS 规范，通过英文问号 <code>?</code> 来允许可选：</p>\n<pre><code class=\"language-ts\">// name 是可选\ndefineProps&lt;{\n  name?: string;\n  tags: string[];\n}&gt;();\n</code></pre>\n<p>如果你想设置可选参数的默认值，这个暂时不支持，不能跟 TS 一样指定默认值，在 RFC 的文档里也有说明目前无法指定。</p>\n<blockquote>\n<p>Unresolved questions: Providing props default values when using type-only props declaration.</p>\n</blockquote>\n<p>不过如果你确实需要默认指定，并且无需保留响应式的话，我自己测试是可以按照 ES6 的参数默认值方法指定：</p>\n<pre><code class=\"language-ts\">const { name = 'Petter' } = defineProps&lt;{\n  name?: string;\n  tags: string[];\n}&gt;();\n</code></pre>\n<p>这样如果传入了 name 则按传入的数据，否则就按默认值，但是，有个但是，就是这样 name 就会失去响应性（因为响应式数据被解构后会变回普通数据），请注意这一点！</p>\n<blockquote>\n<p>需要强调的一点是：这两种校验方式只能二选一，否则会引起程序报错</p>\n</blockquote>\n<h2>defineEmit</h2>\n<p>defineEmit 也是一个方法，它接受的入参格式和标准组件的要求是一致的。</p>\n<blockquote>\n<p>注意：defineProps 是复数结尾，带有 s，defineEmit 没有！</p>\n</blockquote>\n<p>由于 emit 并非提供给模板直接读取，所以需要通过字面量来定义 emits，最基础的用法也是传递一个 string[] 数组进来，把每个 emit 的名称作为数组的 item 。</p>\n<pre><code class=\"language-ts\">// 获取 emit\nconst emit = defineEmit(['chang-name']);\n\n// 调用 emit\nemit('chang-name', 'Tom');\n</code></pre>\n<p>由于 defineEmit 的用法和原来的 emits 选项差别不大，这里也不重复说明更多的诸如校验之类的用法了，可以查看 <a href=\"https://vue3.chengpeiquan.com/communication.html#%E6%8E%A5%E6%94%B6-emits\">接收 emits</a> 一节了解更多。</p>\n<h2>useContext</h2>\n<p>在标准组件写法里，setup 函数默认支持两个入参：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">props</td>\n<td style=\"text-align:left\">object</td>\n<td style=\"text-align:left\">由父组件传递下来的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">context</td>\n<td style=\"text-align:left\">object</td>\n<td style=\"text-align:left\">组件的执行上下文</td>\n</tr>\n</tbody>\n</table>\n<p>这里的第二个参数 context，在 script-setup 写法里，就需要通过 useContext 来获取，一样的，记得先导入依赖：</p>\n<pre><code class=\"language-ts\">// 导入 useContext 组件\nimport { useContext } from 'vue'\n\n// 获取 context\nconst ctx = useContext();\n\n// 打印 attrs\nconsole.log(ctx.attrs);\n</code></pre>\n<p>你也可以对它进行解构，直接获取到内部的数据：</p>\n<pre><code class=\"language-ts\">// 直接获取 attrs\nconst { attrs } = useContext();\n</code></pre>\n<p>对于 context 的使用和注意事项，如果不了解的话，可以在 <a href=\"https://vue3.chengpeiquan.com/component.html#setup-%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8\">setup 的参数使用</a> 了解更多。</p>\n<h2>参考资料</h2>\n<p>以上所有的资料都来自于 Vue 的 rfcs 仓库，原文传送门：<a href=\"https://github.com/vuejs/rfcs/blob/script-setup-2/active-rfcs/0000-script-setup.md\">script-setup - vuejs/rfcs</a> 。</p>\n<p>除了看英文说明适当做了翻译之外，大部分坑点都是自己在 DEMO 里运行出来总结的，后面如果有什么变动的话，建议以官网文档的正式版为准，我也会留意他们正式发布后的变化进行内容更新。</p>\n<h2>结语</h2>\n<p>目前在运行项目的时候，控制台会有提醒：</p>\n<pre><code class=\"language-bash\">[@vue/compiler-sfc] &lt;script setup&gt; is still an experimental proposal.\nFollow its status at https://github.com/vuejs/rfcs/pull/227.\n\n[@vue/compiler-sfc] When using experimental features,\nit is recommended to pin your vue dependencies to exact versions to avoid breakage.\n</code></pre>\n<p>告知 script setup 当前仍然是个实验性的新特性，还没有作为正式特性发布，后面会不会有变化还不好说，本文仅作为目前有用到这个新特性的同学参考。</p>\n<p>更多关于 Vue 3.0 的起步教程，可以在 <a href=\"https://vue3.chengpeiquan.com\">Vue3.0学习教程与实战案例</a> 了解，稍后有时间我也会把这部分内容一起合并进去。</p>\n",
            "title": "聊一聊Vue3.0的script-setup 以及全新的props/emits专属API",
            "date_modified": "2021-03-05T00:48:13.000Z",
            "author": {
                "name": "pengzhixin",
                "url": "https://pengyumo.com"
            }
        },
        {
            "content_html": "<p>[[toc]]</p>\n<p>从 2021 年元旦 Vite 发布 2.0 Beta 版就一直在关注 Vite 的动态，借着春节放假有时间，而且 Vue 3.0 和 Vite 2.0 都才大版本更新上线不久，预感后面会火，先开荒尝试一波，也当给以后工作上的业务先提前踩踩坑，对博客做了第三次重构，这一次把客户端和服务端都重新写了，由 PHP 的 LNMP 全家桶全部换成了前端侧的技术栈。</p>\n<p>在经历了春节假期每天大概花 2 ~ 3 小时的投入，终于如期上线，第一个版本是发布于 2月14日情人节 ，算是给自己的情人节礼物，当时是先部署在我闲置的香港服务器做了一波测试服调试，期间做了一些体验上的优化，然后 2月18日 在休假的最后一天，部署到我正式服务器上了。</p>\n<p>而且特别巧的是，这一天也是 Vite 2.0 正式版发布的日子：<a href=\"https://zhuanlan.zhihu.com/p/351147547\">Vite 2.0 发布了 - 尤雨溪</a>，同一天上线，就感觉特别美好，值得纪念。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2021/01/20210222114853.jpg\" alt=\"LightHouse的打分\"></p>\n<h2>运作流程</h2>\n<p>本次重构后，从开发到部署更新的运作流程图如下，日常只需要维护 GitHub 仓库的代码，其他的都是自动化完成。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2021/01/20210222154414.jpg\" alt=\"博客运作流程\"></p>\n<h2>重构的价值</h2>\n<p>这次重构，并非是因为放假有空就找点事情做，而是带着几个目的来的：</p>\n<ol>\n<li>\n<p>提前开荒 <a href=\"https://github.com/vitejs/vite\">Vite 2.0</a> ，为公司后续的业务提前踩坑，可以为团队进行技术选型提供帮助，因为之前我在做 JSSDK、Vue Plugin 的时候，已经开始脱离 Webpack，用 <a href=\"https://github.com/rollup/rollup\">Rollup</a> 作为构建工具，而 Vite 正是基于 Rollup ，不仅构建速度非常快，而且也像 Webpack 一样提供了热更新，对于一线开发来说，体验上是非常好的，而且它还是 Vue 团队大力推广的新工具，这让我很有兴趣去研究它。</p>\n</li>\n<li>\n<p>了解一下当前的一些新生的前端工具，比如 UI 框架方面之前一直停留在适合 B 端产品的 Ant-Design、 Vuetify 、 饿了么等等，说实话我做 B 端产品的时候才会用，面向 C 端因为有设计稿，我基本上都是手写样式，听闻新一代的 UI 框架 <a href=\"https://github.com/tailwindlabs/tailwindcss\">Tailwind CSS</a> 已经有一段时间了，虽然很奇怪为什么还会回到十年前一样用原子类的 class，“开倒车” 竟然还有 3 万多的 Star，让我非常的好奇到底为什么，结果一用，真香！没错，这次博客的样式，就是用的 Tailwind 。 还有像 CSS 预处理器之前也一直停留在 Sass / Less / Stylus 三驾马车，这一次我抛弃了他们，用上了 <a href=\"https://github.com/postcss/postcss\">PostCSS Language</a> + <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/--*\">CSS Variable</a>，也是真香！</p>\n</li>\n<li>\n<p>借此机会多了解一下生产环境的服务端开发，公司业务几乎没有机会让自己实操服务端，所以大部分情况下都是在跑本机的 Server，很多场景是开发环境下遇不到的，要想进步，还是要多在生产环境磨练。</p>\n</li>\n<li>\n<p>接触更多优秀的开源作品，比如代码语法高亮之前一直只知道 <a href=\"https://github.com/highlightjs/highlight.js\">highlight.js</a> （因为 WordPress 的高亮插件就是用这个……），这一次我是用了 <a href=\"https://github.com/PrismJS/prism\">prism</a> ，更小巧，颗粒度更细，虽然目前还没有太多时间去定制代码高亮的配色，不过后面有时间想要处理，prism 会更加方便。</p>\n</li>\n<li>\n<p>享受从 0 到 1 搭建脚手架的一个过程，目前这个版本算是实现一个简易版的 VuePress ，但是如果一直使用开箱即用的 VuePress ，很多时候并没有想去了解那些功能是怎么实现的，或者用哪些工具可以实现想要的功能（Btw: 我自从用了 Vue-CLI 之后就很久没自己配置 Webpack 了，直到 Rollup 的时候才算重新玩转了一次，这一次的 Vite 又是新的体验）</p>\n</li>\n</ol>\n<p>更多的更多，尽在未来，这肯定不是最后的一个版本，还有非常大的优化空间。</p>\n<h2>重构前的目标</h2>\n<p>其实去年就有想法要对博客做一波改版，但有几个原因导致一拖再拖，一个是因为业务比较忙（这个没办法，工作为重），一个是懒（主要是懒得去思考怎么设计，当然期间有在考虑一些不同的落地方案），还有一个主要的原因是当时 Vue 3.0 刚发布，我当时主要的精力放在踩坑体验 3.0，那段时间，大部分的时间和精力都放在撰写 <a href=\"https://vue3.chengpeiquan.com/\">Vue3.0学习教程与实战案例</a> 上面去了，休息时间有限，能够闲下来的时间也只有下班回来和周末，除掉一些自己的事情外，留下来捣鼓新东西的时间并不算很多，只能先押后了。</p>\n<p>相比 2018 年那次改版，当时只是单纯想重新弄一个干净的博客写东西，这一次的目标是比较明确了，就是从基于 PHP 的 WordPress，用前端的技术栈全部重构一遍，做一个纯前端的博客出来，当然还要保留 SEO ，就要求还要上 SSR（Server Side Render） 或者 SSG（Server Side Generation） 。</p>\n<h2>技术栈的选择</h2>\n<p>由于开工前已经是 2021 年了，因为有前面几个月玩 Vue 3.0 的基础打底，非常想用 3.0 来重构博客，加上元旦期间 Vite 2.0 Beta 版刚好发布（就很突然），注意力完全放在了 Vue3 和 Vite2 上面，非常想跑一下两者结合有多爽。</p>\n<p>由于重构的最终目标还是要保持网站的 SEO 能力，所以肯定不能使用默认的 SPA 应用模式，要走服务端渲染，所以技术栈方面只需要考虑两条线：</p>\n<h3>基于 SSR</h3>\n<p>虽然在此之前考虑过几个方案，最开始是优先考虑做 SSR ，考虑过 <a href=\"https://github.com/nuxt/nuxt.js\">Nuxt</a> 、<a href=\"https://github.com/shuidi-fed/vapper\">Vapper</a> 等一些比较流行的开箱即用的 SSR 框架，但这些框架目前都还在弄 Vue 2.0，甚至部分框架看起来有点 “弃坑” 的趋势（背靠字节大厂的 Vapper 居然一年多没更新了 emm…… ）。</p>\n<p>加上搞 SSR 的话，服务器成本比较高，我的低配 ECS 可能 Hold 不住，好好玩一玩的话还要投点钱，想了想先算了，那么退而求次就是上 SSG 。</p>\n<h3>基于 SSG</h3>\n<p>玩转 SSG 也是有考虑过一些开箱即用的 SSG 框架，比如用的人最多的 <a href=\"https://github.com/hexojs/hexo\">Hexo</a>，但我本身一直对 Hexo 不太感兴趣，而且似乎满大街随便找一个独立博客都是基于 Hexo 的，模板也千篇一律，缺乏个人特色。</p>\n<p>好友小毅 <a href=\"https://github.com/chawyehsu\">@chawyehsu</a> 安利的 <a href=\"https://github.com/saberland/saber\">Saber</a>，跑了个 demo 玩了一下，觉得真的蛮不错的，原本打算就直接用 Saber 的，不过目前 Saber 还是以 Vue 2.0 为主（听说下个版本会支持 3.0 ，不过也不知道什么时候会发布），由于内心实在是非常想用 Vue3 ，所以这个方案最终作为备选。</p>\n<p>好吧，对 3.0 的执念，还让我想起两个 Vue 官方的作品：<a href=\"https://github.com/vuejs/vuepress\">VuePress</a> 和它的弟弟 <a href=\"https://github.com/vuejs/vitepress\">VitePress</a>，他们的新版本都是基于 Vue 3.0，而且已经可以用了，但一直以来我觉得它们都更适合用来写项目文档……</p>\n<h3>最终敲定</h3>\n<p>期间，Vite 官网在 2.0 Beta 版发布后，也新增了一 Part <a href=\"https://vitejs.dev/guide/ssr.html\">Server-Side Rendering | Vite</a> 指导如何实现 Vite SSR，我觉得可行。</p>\n<p>加上有两个开源项目让我非常感兴趣，一个是 <a href=\"https://github.com/frandiox/vite-ssr\">vite-ssr</a>，一个是 <a href=\"https://github.com/antfu/vite-ssg\">vite-ssg</a>，我也分别对他们跑了 demo ，很给力，So，最后决定基于这两个开源项目之一，选择自己搭脚手架……</p>\n<p>最终用到的核心技术是：</p>\n<blockquote>\n<p><br>Vite 2.0 —— 超快的构建工具<br><br><br>\nVue 3.0 —— 更强大更灵活的 Vue<br><br><br>\nSSG —— 服务端渲染方案，利于 SEO 进行内容收录<br><br><br>\nPWA —— 构建离线应用<br></p>\n</blockquote>\n<p>当然还要考虑的事情很多，每个环节还要用到不同的技术栈，具体我在下面逐个环节说明。</p>\n<h2>重构过程分析</h2>\n<p>下面来说说决定重构之后，整个思考的过程顺序，以及对每一个技术模块的技术栈选型原因分析吧，希望对有计划重构项目的朋友带来一些帮助。</p>\n<h3>构建工具</h3>\n<p>其实 <a href=\"https://github.com/vuejs/vue-cli\">Vue-CLI</a> 对 Vue 3.0 的支持已经非常好了，我的 <a href=\"https://vue3.chengpeiquan.com/\">Vue 3.0 教程</a> 也是基于 Vue-CLI 写的。</p>\n<p>之所以选择 Vite，一方面是它的构建速度真的比 <a href=\"https://github.com/webpack/webpack\">Webpack</a> 要快好多，另一方面是，自从 Vue 3.0 推出以来， Vue 官方团队就一直在投入精力优化和宣传 Vite，尽管 1.0 版本的功能和生态不如人意，但超快的构建速度已经体现了出来。</p>\n<p>加上在我准备动手重构的时候官方刚好发布了 2.0 大更新，对比了 1.0 简直是质的飞跃，让我非常感兴趣，而且按照目前官方团队的态度，我觉得后面 Vite 会逐步代替 Vue-CLI ，提前了解，提前踩坑，对以后的工作也有帮助。</p>\n<p>而且在生态方面，Vite 2.0 的各种支持都算很完善了，不得不说整个春节期间，Vue 团队的人都在忙着给 Vite 2.0 干活，我在春节提的 Issue，基本上 2 ~ 3 小时就能给我回应，解决问题速度非常快（大过年的耶！），重构过程感觉自己拥有一个强大的技术支持团队一样!</p>\n<p>开荒虽然辛苦，但也有另一番乐趣！</p>\n<h3>服务端渲染</h3>\n<p>这是在选择合适的构建工具之后，应该考虑的第二件事。</p>\n<p>个人博客之前一直选择用 WordPress ，一方面除了有 <a href=\"https://github.com/licess/lnmp\">LNMP</a> 一键部署等快速搭建方案，和各种各样的模板之外，主要也是归功于 WP 对 SEO 的支持也是非常好，我这个博客的日常访问都是来自于搜索引擎。</p>\n<p>单纯选择用 Vue 3.0 重新开发 SPA 应用肯定会丢失 SEO，所以才有了前面的 <a href=\"#%E6%8A%80%E6%9C%AF%E6%A0%88%E7%9A%84%E9%80%89%E6%8B%A9\">技术栈的选择</a>，本次是通过 SSG 方案来落地服务端渲染。</p>\n<h3>项目架构规划</h3>\n<p>在开始动手之前，还要对网站架构做一波规划，盲目动手只能给自己挖坑，自己的博客虽然说内容不多，但也有一些东西要考虑：</p>\n<ol>\n<li>\n<p>对外展示的网站结构要保持不变，也就是原来的页面地址要尽量一样，避免用户访问不到原来的内容</p>\n</li>\n<li>\n<p>对实在不能保持原样的 URL ，或者要废弃的页面，需要做 301 重定向</p>\n</li>\n<li>\n<p>降低后续更新的构建和部署成本，尽量自动化，减少人工操作</p>\n</li>\n<li>\n<p>数据需要无缝迁移，不能有丢失</p>\n</li>\n<li>\n<p>减少服务器压力，把大部分资源消耗放在开源平台上（诸如 Github、jsdelivr CDN 等等）</p>\n</li>\n</ol>\n<p>当然其他的如移动端适配啥的也要看情况顾及，之前博客还有一个小程序版本，不过因为没人看（害，真的整整一年过去了，完全没人看小程序版本…），所以小程序的依赖保留没有在这次的重构兼容考虑范围里，重构完毕后我就直接把原来的服务停了，回头有空了再重新写一版接口给小程序用。</p>\n<h3>模板开发</h3>\n<p>基于 Vue 3.0 的项目，主要的模板肯定还是 Vue 文件，站点的主要结构、页面的布局、美化等等都是基于 <code>.vue</code> 文件，只需要按照原来的习惯，路由页面放在你的 <code>src/views</code> 文件夹下，组件模板放置于 <code>src/components</code> 下，就可以自动生成路由访问。</p>\n<p>同时也加入了 <code>.md</code> 文件的支持，用于书写 Markdown 格式的内容，日常记录博客会更方便，并且像 VuePress 那样，同时支持在 Markdown 里嵌套 Vue，让博客的定制更加灵活。</p>\n<p>整个项目的路由页面、组件结构，跟你平时开发 Vue 项目是完全一样的，无缝切换。</p>\n<pre><code class=\"language-html\">src\n├─components\n│  ├─Footer.vue\n│  └─Header.vue\n└─views\n   ├─article\n   │  ├─[page].vue\n   │  └─rewrite-in-vite.md\n   ├─about.md\n   └─index.vue\n</code></pre>\n<p>在这里推荐几个非常方便的 Vite 插件：</p>\n<blockquote>\n<p><br><a href=\"https://github.com/hannoeru/vite-plugin-pages\">vite-plugin-pages</a> ： 能够自动读取指定目录下的 Vue / Md 文件生成 Vue 路由，只需要管理好 views 文件夹的层级关系，无需再单独维护路由配置<br><br>\n<br><a href=\"https://github.com/antfu/vite-plugin-md\">vite-plugin-md</a> ： 一个能让 Markdown 文件像 Vue 组件一样导入使用的插件，它也基于 markdown-it，支持进行一系列 md 生态扩展<br><br>\n<br><a href=\"https://github.com/antfu/vite-plugin-components\">vite-plugin-components</a>：可以像 VuePress 一样，无需 import，会自动根据组件的标签名去 components 目录下寻找组件<br></p>\n</blockquote>\n<p>基本上你只需要按照开发 Vue 项目的习惯去开发就可以了，如果有一些思路被卡住不知道怎么下手，可以参考我仓库源码。</p>\n<h3>样式处理器</h3>\n<p>有设计稿的时候我更喜欢借助 CSS 预处理器（目前常用 <a href=\"https://github.com/stylus/stylus\">Stylus</a>），借助他们的变量 、 嵌套书写，以及 Mixin 、 Extend 等功能，避免写原生 CSS 带来的烦恼。</p>\n<p>没有设计稿的时候，会用上 <a href=\"https://github.com/vueComponent/ant-design-vue\">Ant Design</a> 等 UI 框架来帮我减少页面设计上的一些时间浪费，但这些框架通常更适合用在 B 端产品。</p>\n<p>去年底在知乎刷到过一篇 <a href=\"https://www.zhihu.com/question/337939566\">如何评价CSS框架TailwindCSS？</a> ，了解到一款全新的 CSS 框架 Tailwind CSS，乍一看很像是在开历史的倒车，回归原子类 className ，评价也是褒贬不一，自己光看文档的时候也是想着这啥玩意…</p>\n<p>但是考虑到如果真的是开倒车，凭什么可以拿到 3 万的 Star，抱着试一下的心态在这次重构里面引入尝试，确实真香！</p>\n<p>目前感受到的好处就是：</p>\n<blockquote>\n<p>延续 CSS 的属性命名，你需要什么属性自己放，也就是自己必须有一定的 CSS 基础，特别是在多端适配方面，不用担心框架用久了自己不会写 CSS 的问题</p>\n</blockquote>\n<p>比如，你要实现一个容器内完全居中，手写 CSS 是：</p>\n<pre><code class=\"language-css\">.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 100px;\n  height: 100px;\n}\n</code></pre>\n<p>用 Tailwind CSS 的写法是：</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;flex justify-center items-center w-40 h-40&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>写法跟你在 VSCode 里自动补全代码时，敲入的命令非常接近，不像传统的 UI 框架一样，你写个标签就自动生成按钮，都不知道它是怎么写出来的（这也是我比较少想用 UI 框架的原因，我怕久了自己都不会写了），实际上，使用 Tailwind 之后，你还是在自己写 CSS， 只不过更方便了！</p>\n<blockquote>\n<p>支持 CSS tree-shaking ，构建后的文件非常迷你</p>\n</blockquote>\n<p>传统的 Atom CSS ，引入了就得整包引入，而 Tailwind 可以借助 PostCSS ，可以在最终项目构建的时候，抽离出我们用到的样式，用不到的会被直接扔掉。</p>\n<p>我自己体验了一下，核心样式文件在配置 Purge 之前构建出来大概有 6M 多，Purge 之后只有 24K ！</p>\n<blockquote>\n<p>可以组合使用，类似于 CSS 预处理器的 Extend</p>\n</blockquote>\n<p>比如，我要写一个通用的图片样式，让图片具备自适配不变型的效果，我只需要借助 @apply 像这样子：</p>\n<pre><code class=\"language-css\">.img {\n  @apply w-full h-full object-cover;\n}\n</code></pre>\n<p>编译出来就是我想要的效果：</p>\n<pre><code class=\"language-css\">.img {\n  width: 100%;\n  height: 100%;\n  -o-object-fit: cover;\n  object-fit: cover;\n}\n</code></pre>\n<blockquote>\n<p>支持目前主流的暗黑模式，通过 <code>dark:xxxxx</code> 的前缀就可以轻松定制两款皮肤</p>\n</blockquote>\n<p>点一下切换皮肤：<Theme /></p>\n<blockquote>\n<p>用了 Tailwind 之后，你几乎可以不用写 Sass / Stylus 了，那么问题来了：如何弥补 CSS 预处理器提供的一些功能？</p>\n</blockquote>\n<p>借助 <a href=\"https://github.com/postcss/postcss\">PostCSS Language</a> 和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/--*\">CSS Variable</a>，可以轻松的书写像 CSS 预处理一样的嵌套和变量。</p>\n<pre><code class=\"language-css\">a {\n  color: var(--fg-deeper);\n  text-decoration: none;\n\n  &amp;:hover { \n    border-bottom: 1px solid var(--fg-light);\n  }\n}\n</code></pre>\n<p>独立的文件使用 <code>.postcss</code> 或者 <code>.pcss</code> 作为文件后缀，在 Vue 组件里则使用 <code>&lt;style lang=&quot;postcss&quot;&gt;&lt;/style&gt;</code> 来指定 PostCSS Language 。</p>\n<p>当然，说的再多也不如亲手写一写，我之前在知乎也是看了好久始终不能决定用不用，之前赶业务也没时间，这一次也终于动手体验了一把，后悔，特别后悔，后悔怎么没有早点用！！！</p>\n<h3>SEO 优化</h3>\n<p>虽然前面的 <a href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93\">服务端渲染</a> 帮我们解决了空 HTML 文档的问题，但要更好的进行 SEO 优化，还需要落实到具体的页面上去。</p>\n<p>比如页面的 <code>title</code> 、 <code>description</code> 、 <code>keyword</code> 等等，这里我是用到了以下两个工具来帮我实现每个页面的 TKD 定制。</p>\n<p><a href=\"https://github.com/jonschlinkert/gray-matter\">gray-matter</a>：支持对 <code>.md</code> 文件的 TKD 优化，你可以在 Markdown 文件的最前面加入这样的代码，即可实现对页面展示对应的 TKD 信息。</p>\n<pre><code class=\"language-html\">---\ntitle: 这是页面的标题\ndesc: 这是页面的描述\nkeywords: 关键词1,关键词2,关键词3\n---\n\n下面是要书写的 Markdown 内容…\n</code></pre>\n<p><a href=\"https://github.com/vueuse/head\">@vueuse/head</a>：可以让你在 <code>.vue</code> 文件里实现优化，在 Vue 组件里的 <code>script</code> 部分，写入以下的代码，就可以实现 TKD 信息的配置。</p>\n<pre><code class=\"language-ts\">import { useHead } from '@vueuse/head'\n\nuseHead({\n  meta: [\n    {\n      name: 'title',\n      content: '这是页面的标题'\n    },\n    {\n      name: 'description',\n      content: '这是页面的描述'\n    },\n    {\n      name: 'keywords',\n      content: '关键词1,关键词2,关键词3'\n    }\n  ],\n})\n</code></pre>\n<p>你还可以扩展更多的信息上去，具体都在各自对应的 Github 仓库的 README 里有详细的说明。</p>\n<p>当然，SEO 优化远远不止这一点，包括 robots 、 链接语义化 、减少死链 、 旧地址重定向等等，后面也会有说明。</p>\n<h3>静态资源处理</h3>\n<p>静态资源指 js 、 css 、 img 这些资源，放自己服务器也不是不好，我之前就是放自己服务器上，没有去改，虽然 WordPress 虽然有配置 CDN 的插件，但是 CDN 平台诸如七牛、又拍云，免费额度只针对 http , 都是需要付费才可以使用 https，总的来说还是要多出一笔钱来处理这块服务，反正自己的博客访问量不大，而且技术博客很少多媒体资源，日常使用的带宽消耗很少，我三年前在阿里云充的 50 块钱，三年过去了到现在还有 45.91 …</p>\n<p>不过这次改版就不一样了，后续我可能还会开辟一些图片模块，加上改版后是把项目托管到了 Github ，先天优势存在，那么就要多考虑一下利用 Github 提供的免费服务了！</p>\n<p>开发过 NPM 包的同学，或者日常使用 NPM 插件比较细心的同学，应该能够发现发布在 NPM 上的包都自动部署到了 CDN 平台，诸如 jsdelivr 、 unpkg 、cdnjs 等等，那么 Github 和这些 CDN 能关联吗？在此之前其实我也没去关注能不能，但这一次我查了一下，确实可以，而且其中对国内访问速度最友好的 jsdelivr ，支持度最高！超棒的！</p>\n<p>关于 jsdelivr 的速度可以参考：<a href=\"https://www.zhihu.com/question/20227463/answer/370662453\">国内有哪些靠谱的 Javascript 库 CDN可用？</a>，也可以测试下我的博客，我自己对测试结果还是挺满意的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2021/02/20210221185258.jpg\" alt=\"测试我自己网站的速度\"></p>\n<p>所以最后我是把所有静态资源都指向了 jsdelivr CDN ，它无需你自己再做任何部署工作，只需要把代码文件更新到你的 GitHub 仓库里，就会自动同步到 jsdelivr 。</p>\n<p>访问格式为在 <a href=\"https://www.jsdelivr.com/?docs=gh\">jsdelivr CDN 官网</a> 有案例说明，更多用法可以查看官网的文档 <a href=\"https://www.jsdelivr.com/features#gh\">Features - jsdelivr</a>，为了避免项目源码过大，你可以像我一样单独创建一个类似 <a href=\"https://github.com/chengpeiquan/assets-storage\">assets-storage</a> 这样的仓库用来存储这些静态资源，在仓库的 README 也有简单介绍下如何引用 CDN 地址和清除 CDN 缓存。</p>\n<p>回到项目里，只需要在 <a href=\"https://github.com/chengpeiquan/chengpeiquan.com/blob/main/vite.config.ts\">vite.config.ts</a> 里修改 <code>base</code> 的路径即可。</p>\n<pre><code class=\"language-ts\">export default defineConfig({\n  base: isDev ? '/' : 'https://cdn.jsdelivr.net/gh/chengpeiquan/chengpeiquan.com@gh-pages/',\n})\n</code></pre>\n<p>详细可以看官网的文档 <a href=\"https://vitejs.dev/config/#base\">Configuring Vite | Vite</a>。</p>\n<p>当然这种方式如果你用平时的命令行或者老乌龟界面工具来提交文件，始终还是比较麻烦，这里推荐一个现成的图床工具 <a href=\"https://github.com/Molunerfinn/PicGo\">PicGo</a> ，支持多个平台的 CDN 服务，其中就有 Github 。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2021/02/20210221185205.jpg\" alt=\"PicGo 图床界面\"></p>\n<p>你可以在 Github 仓库上的 <a href=\"https://github.com/Molunerfinn/PicGo/releases\">Releases</a> 下载最新的客户端版本，只是使用的话，可以单独下载对应系统的安装文件，不需要克隆整个仓库下来自己构建。</p>\n<h3>资源导出</h3>\n<p>本次的资源导出主要是指原来的那些图片，前面有提到，我之前没有启动 CDN 服务，所以图片资源都还在自己的服务器上。</p>\n<p>WordPress 的上传资源都存放在 <code>/wp-content/uploads/</code> 目录下，阿里云非常方便的就是，你可以连 SFTP 上去把这些文件直接拖下来就可以了。</p>\n<p>重新传到 Github 上又非常简单，克隆你的仓库下来后，放到指定的文件夹里，重新提交就可以了。</p>\n<p>等未来某一次你不想继续用 Github 托管了，只需要把仓库拉下来，所有文件又都在了，都是非常方便和灵活。</p>\n<h3>爬虫编写</h3>\n<p>这一部分主要针对原来的文章，虽然我之前的 WordPress 就开启了 Markdown 编辑器支持，但如 <a href=\"#seo-%E4%BC%98%E5%8C%96\">SEO 优化</a> 里提到的，缺少很多 TKD 信息配置，而且里面的图片地址也都要更换为 CDN 的路径，所以就算用现成工具去处理 HTML / XML 转 Markdown，都还要去补充这些信息，也比较繁琐。</p>\n<p>所以是借助了 Node 编写了个静态爬虫，在爬取过程中对一些内容进行追加、转换。</p>\n<p>具体的实现可以参考我之前写的 <a href=\"https://chengpeiquan.com/article/node-web-crawler\">网站改版迁移经验记录：基于node的爬虫编写</a> ，这里就不重复赘述了。</p>\n<h3>数据统计</h3>\n<p>既然是 Vue 项目，那么当然支持 Vue 系的统计插件，之前写的两个统计平台插件，都是可以开箱即用的，均已支持 Vue 3.0 的使用。你可以在 <a href=\"https://github.com/chengpeiquan/chengpeiquan.com/blob/main/src/main.ts\">main.ts</a> 里了解如何开启流量的统计上报功能，如果你需要记录埋点，也都有 API 可以轻松触发数据的上报。</p>\n<p>百度统计：<a href=\"https://github.com/chengpeiquan/vue-baidu-analytics\">vue-baidu-analytics</a></p>\n<p>友盟统计：<a href=\"https://github.com/chengpeiquan/vue-cnzz-analytics\">vue-cnzz-analytics</a></p>\n<h3>服务端开发</h3>\n<p>服务端之前是 WordPress 所依赖的 Nginx + PHP + MySQL ，这一次重构也把服务端直接换了，更换为 Node.JS + Express ，通过 PM2 守护进程来运行在阿里云。</p>\n<p>对，这一次没有数据库，第一版暂时不打算做数据库，暂时用不到，目前大部分数据都已经迁移到 Github 仓库了，下个版本功能迭代用到了再考虑弄一下。</p>\n<p>我的服务器系统是 CentOS 7，也就是 Linux 系统，关于 Linux 下如何安装 Node ，搜素引擎很多方法，这里也不赘述了，放几个自己用到的关键命令参考吧。</p>\n<ol>\n<li>清除缓存然后升级系统和软件</li>\n</ol>\n<pre><code class=\"language-html\">sudo yum clean all\nsudo yum makecache\nsudo yum update\nsudo yum upgrade -y\n</code></pre>\n<ol start=\"2\">\n<li>安装 NPM 并通过 stable 安装最新版本的 Node</li>\n</ol>\n<pre><code class=\"language-html\">sudo yum install npm\nsudo npm install -g n\nsudo n stable\n</code></pre>\n<ol start=\"3\">\n<li>全局安装 <a href=\"https://github.com/yarnpkg/yarn\">yarn</a> ，没错，我现在更喜欢用 yarn 来进行包管理，这一步你可以跳过</li>\n</ol>\n<pre><code class=\"language-html\">npm i -g yarn\n</code></pre>\n<ol start=\"4\">\n<li>然后是全局安装 <a href=\"https://github.com/Unitech/pm2\">pm2</a>，这个是必须要装的，否则我们的终端一关，服务就停了，需要通过 PM2 来守护进程，当然，你也可以用 <a href=\"https://github.com/foreversd/forever\">forever</a> 。</li>\n</ol>\n<pre><code class=\"language-html\">yarn global add pm2\n</code></pre>\n<p>其他的步骤就不用说了，创建服务器的文件夹，初始化，安装 <a href=\"https://github.com/expressjs/express\">express</a> 或者其他你更熟悉的服务程序，搞起吧！</p>\n<blockquote>\n<p><br>有几件事要特别叮嘱一下：<br><br>\n<br>1. 因为服务端变了，如果原来有开启 HTTPS，记得重新配置你的 SSL 证书（我用的是阿里云的免费证书，只需要 1 年更换 1 次）<br><br>\n<br>2. 域名也要重新做 301 重定向（HTTP 强切 HTTPS ， WWW 强切无 3W 等）<br><br>\n<br>3. 检查之前是否有在推广的的链接挂掉了，也要重新 301 到新地址 （比如 RSS 源之前是 /feed/ ，现在是 /feed.xml）<br><br>\n<br>4. 最重要的，配置上对路由 history 模式的支持<br></p>\n</blockquote>\n<p>第一版其实不复杂，后面有需要会继续迭代。</p>\n<h3>自动化部署</h3>\n<p>代码托管在 GitHub 的好处就是 GitHub Actions 可以帮我们实现 CI / CD，通过配置分支的 push 或者 pull_request 等行为来实现自动触发项目的构建打包，并实现一键部署到阿里云服务器。</p>\n<p>具体的脚本可以参考我写的 <a href=\"https://github.com/chengpeiquan/chengpeiquan.com/blob/main/.github/workflows/github-ci.yml\">workflow</a> ，里面都提供了注释。</p>\n<p>workflow 里所有以 <code>secrets.XXXXXX</code> 的格式均为仓库独立配置的密钥变量，在仓库的 <code>settings</code> &gt; <code>Actions secrets</code> 里添加。</p>\n<p>其中一些关键环节说明如下：</p>\n<ol>\n<li>\n<p><code>on</code> 是指分支行为，我配置了合并分支才会触发，因为平时都是托管在 <code>develop</code> 分支，包括未开发完毕的功能，写一半的文章草稿，只有确认可以发布的代码，才会合并到 <code>main</code> 进行更新</p>\n</li>\n<li>\n<p><code>jobs</code> 是触发自动打包 / 发布一系列行为的各种操作，从上到下按顺序处理，其中的 ACCESS_TOKEN 是 GitHub 的 Token，请来 <a href=\"https://github.com/settings/tokens\">Personal access tokens</a> 创建，创建后只会显示一次，请保存好，后面涉及到 Token 的地方可以重复使用同一个 Token，请勿泄露！</p>\n</li>\n<li>\n<p><code>gh-pages</code> 分支是打包完毕后的文件，推送到阿里云服务器的也是这个分支下的所有文件，之所以托管一份在 GitHub，是因为我们前面部署了 CDN 支持，JS / CSS 文件是需要读取这个分支的 CDN 文件</p>\n</li>\n<li>\n<p>部署到阿里云的环节，配置的 <code>SERVER_SSH_KEY</code> 是自己服务器的密钥对，如果你也是跟我一样使用阿里云的 ECS ，可以参考 <a href=\"https://www.alibabacloud.com/help/zh/doc-detail/51793.htm\">创建SSH密钥对</a>， 创建后还需要绑定给实例才能激活生效，绑定操作请参考 <a href=\"https://www.alibabacloud.com/help/zh/doc-detail/51796.htm\">绑定SSH密钥对</a></p>\n</li>\n<li>\n<p><code>SERVER_IP</code> 是自己服务器的公网IP，这个其实可以不用配置为密钥变量，因为 <code>ping</code> 一下你的域名也知道是什么 IP ，只是因为我有两台服务器，所以配置为变量可以方便的通过 <code>SERVER_IP</code> 和 <code>SERVER_IP_TEST</code> 去切换，其他变量其实也有一个 TEST 版本</p>\n</li>\n<li>\n<p>最后的 <code>TARGET</code> 是你在服务器上，node 服务器所安装的目录。</p>\n</li>\n</ol>\n<p>如果其中有什么环节不清楚的，善用搜索引擎，或者到我博客仓库给我提 issue 也可以。</p>\n<p>如果你不是托管在 GitHub ，而是别的 Git 平台诸如自建的 Gitlab ，你也可以通过 <a href=\"https://github.com/jenkinsci/jenkins\">Jenkins</a> 去配置 CI / CD 的支持。</p>\n<h3>离线应用构建</h3>\n<p>使用 Vue-CLI 创建新项目的时候，可以了解到有一个选项是关于 PWA 的，关于 PWA 的定义建议直接阅读 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps\">渐进式 Web 应用（PWA） | MDN</a> 。</p>\n<p>Vite 官方团队也对 PWA 做了支持，通过 <a href=\"https://github.com/antfu/vite-plugin-pwa\">vite-plugin-pwa</a> 可以方便的实现一个离线应用的配置。</p>\n<blockquote>\n<p><br><s>不过目前发现了一个问题就是，当 <code>vite.config.ts</code> 的 <code>base</code> 选项设置为 CDN 地址时，构建出来的 PWA manifest 资源路径会读取错误，原因是 manifest 不能走 CDN，要单独从网站内读取，虽然跟作者提了优化建议（详见 <a href=\"https://github.com/antfu/vite-plugin-pwa/pull/25\">#25</a>），不过还需要点时间去优化。</s><br><br>\n<br><s>所以在原版进行版本更新之前，自己先发布了个私有调试包 fix 了这个问题，有遇到一样情况的朋友可以先安装 <a href=\"https://www.npmjs.com/package/@chengpeiquan/vite-plugin-pwa\">@chengpeiquan/vite-plugin-pwa</a> 这个去用，不过最好还是留意原版的更新，这个私有包不会长期维护。</s><br><br>\n<br>2021-02-22更新： 目前原版已更新，Fix 了我反馈的问题，请使用 v0.5.3 以后的版本可以避免该问题的产生，给作者点赞！<br></p>\n</blockquote>\n<p>关于 PWA 的配置可以参考我的项目，这里单独说一下需要特别注意的点：</p>\n<ol>\n<li>\n<p>因为使用了 CDN，所以 <code>scope</code> 和 <code>manifest.start_url</code> 选项需要显式指定，否则资源会读取出错</p>\n</li>\n<li>\n<p>基于我上面提到的路径问题，从 v0.5.3 开始，配置 CDN 的同时，也需要显式指定 <code>base</code> 选项，避免出现 404</p>\n</li>\n</ol>\n<p>其他的选项根据实际需要去处理就可以了。</p>\n<h2>结语</h2>\n<p>因为网站的设计一向不是我的专长，加上不喜欢花里胡哨的东西，所以这一次重构后的 UI 设计还是基本继承了原来的风格。</p>\n<p>但也有一些新的迭代，比如加上了跟随系统的暗黑风格（也可以通过导航右上角进行手动切换），还有首页的变化，对于内容不多的博客来说，挺好的一个 idea，这是来自好友小毅 <a href=\"https://chawyehsu.com/\">The Art of Chawye Hsu</a> 和 Vite 开发者 Antfu <a href=\"https://antfu.me/\">Anthony Fu</a> 的博客参考。</p>\n<p>当然，整个项目的重构，更多的技术支持来自于 Anthony，他也是 Vue 和 Vite 官方团队的开发者，他比我早几天上线的 <a href=\"https://antfu.me/posts/rewrite-in-vite\">Rewrite in Vite</a> 给了我很多思路，很多基于 Vite 的插件也是他写的，都是在这几天发布和迭代，有那种瞌睡来了枕头的感觉，美妙！</p>\n<p>完整的项目依赖和配置请查看仓库的 <a href=\"https://github.com/chengpeiquan/chengpeiquan.com/blob/main/package.json\">package.json</a> 和 <a href=\"https://github.com/chengpeiquan/chengpeiquan.com/blob/main/vite.config.ts\">vite.config.ts</a> ，整个项目也完全开源了，具体的实现可以查看 <a href=\"https://github.com/chengpeiquan/chengpeiquan.com\">Github 仓库</a> ，在这里就不赘述了，如果觉得对你有用，欢迎 Star 。</p>\n",
            "title": "重构于Vite",
            "date_modified": "2021-02-18T23:54:00.000Z",
            "author": {
                "name": "pengzhixin",
                "url": "https://pengyumo.com"
            }
        },
        {
            "content_html": "<p>[[toc]]</p>\n<p>前几天愚人节的时候，大话手游官网上了一个专题（<a href=\"https://dhxy.163.com/2020/gsq/\">专题地址</a>），里面很多图片位置都使用了一个类似电影那种画面抖动的效果（目前只剩下一个slogan了，其他都下线了），很好奇是怎么实现的，于是扒了一下页面的源码，了解了一些实现思路，整理一下以后可能会用到。</p>\n<h2>效果</h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/04/1.gif\" alt=\"\"></p>\n<h2>起因</h2>\n<p>其实这个需求如果是直接给你做，你能不能马上有思路去做出来呢？相信大部分人都会有，那我为啥还要去看他们怎么实现的呢？</p>\n<p>想做这件事的原因，主要是：</p>\n<p>1、想知道对方是怎么实现的，那个抖动的特效，是有素材还是直接前端处理出来的，是不是在自己的预料之中。</p>\n<p>2、自己虽然能马上想到一些实现方案，但还是想看看是否有更优秀的解决办法，可以偷师学习！</p>\n<p>3、看看这个效果的素材是怎么处理的，以后遇到类似的需求，我是不是可以把一些锅甩给设计师？</p>\n<h2>思路</h2>\n<p>在看它是怎么实现之前，先凭经验猜测了一下，有多少种可能实现的方式：gif动图、视频、flash、逐帧动画、图片切换、背景图切换、svg、canvas…（前端牛逼啊！！！！）</p>\n<p>当然每种方法的实现成本不一样，对应的体验和性能也不一样，思路有了，那么来验证一下官网是怎么做的。</p>\n<h2>探路</h2>\n<p>我开始以为是用的视频，因为按网易游戏以往的尿性来说，营销页面上的动态类主视觉基本都是用视频来实现的…那么要怎么看实现方法呢？当然是看DOM啊！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/04/1-1.jpg\" alt=\"\"></p>\n<p>所以，用的是canvas，那就有趣了！还好不是视频，直接弄个视频引入的话也就没这篇文章什么事了…</p>\n<p>canvas的动画效果，都是一帧一帧的定时走出来的，这说明素材是来自设计师之手，不一定是前端直接处理的。</p>\n<p>接下来就找素材了，这种效果的素材，基本上都是图片，找图片的过程就比较简单了，作为主视觉上这么大的slogan，结合刚刚查看DOM的时候，你发现那个地方的className就叫slogan，那么对应的素材命名，肯定也跟slogan有关，单刀直入切到img，搜索slogan关键词，全都出来了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/04/2.jpg\" alt=\"\"></p>\n<p>可以看出他们是把整个动画过程的每一帧，都处理了一张图片素材，我们先把素材弄下来。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/04/3.jpg\" alt=\"\"></p>\n<p>一共有30帧，30张一样尺寸的素材，现在素材有了，接下来就可以开始尝试效果复原。</p>\n<h2>实现</h2>\n<p>实现方案我上面说了，那就一个方案一个方案来看怎么实现，完整的在线demo在文末有地址。</p>\n<p>方案根据推荐度从低到高说起吧，实现难度基本上也是从低到高这样…</p>\n<h3>方案一：使用gif动图</h3>\n<p>先从最容易想到的方案说起吧，动图从制作成本来说是最省事的…只需要一个img标签就可以导进来了。</p>\n<p>【推荐】★★★☆☆</p>\n<p>【优点】简单，直接导个gif引入就完事，纯html。</p>\n<p>【弊端】一般来说动图都会比较大，像demo里面只有一个slogan动图都去到了866KB，太多的gif对页面的渲染速度有影响，用户体验不是最佳。</p>\n<pre><code class=\"language-javascript\">// html\n&lt;section class=&quot;section section-01&quot;&gt;\n  &lt;div class=&quot;img&quot;&gt;\n    &lt;img src=&quot;img/slogan.gif&quot;&gt;\n  &lt;/div&gt;\n&lt;/section&gt;\n</code></pre>\n<h3>方案二：切换图片地址</h3>\n<p>结合我们的素材，已经是处理好一帧一帧这样的过渡状态，那通过定时切换的效果，把他们按指定的时间和顺序切下去，也可以达到想要的效果。</p>\n<p>【推荐】★★☆☆☆</p>\n<p>【优点】简单，批量导出每一帧的png素材出来，定时替换图片的地址就完事（而且每一帧的素材都不会很大）。</p>\n<p>【弊端】需要频繁的操作DOM，性能方面开销太大。</p>\n<pre><code class=\"language-javascript\">// html\n&lt;section class=&quot;section section-02&quot;&gt;\n  &lt;div class=&quot;img&quot;&gt;\n    &lt;img src=&quot;img/0.png&quot;&gt;\n  &lt;/div&gt;\n&lt;/section&gt;\n\n// js\n&lt;script type=&quot;text/javascript&quot;&gt;\n  const slogan = {\n    index: 0,\n    indexMax: 29,\n    time: 0,\n    dom: document.querySelector('.section-02 .img img'),\n    auto(speed){\n      let change = setInterval( () =&gt; {\n        // 动态调整图片帧显示\n        this.index &lt; this.indexMax ? this.index++ : this.index = 0;\n        this.dom.setAttribute('src', `img/${this.index}.png`);\n\n        // 每运行10次动画周期后销毁定时器，进行垃圾回收后再重新创建\n        this.time += speed;\n        if ( this.time &gt; this.indexMax * speed * 10) {\n          clearInterval(change);\n          change = null;\n          this.time = 0;\n          this.auto(speed);\n        }\n      }, speed);\n    }\n  }\n  slogan.auto(100);\n&lt;/script&gt;\n</code></pre>\n<h3>方案三：使用定时器切换背景图</h3>\n<p>【推荐】★★☆☆☆</p>\n<p>和方法二比较类似，只不过方法二是切换图片的src，这里是切换div的样式，来达到换背景图的效果，优缺点说起来差不多。</p>\n<pre><code class=\"language-javascript\">// html\n&lt;section class=&quot;section section-03&quot;&gt;\n  &lt;div class=&quot;img bg&quot;&gt;&lt;/div&gt;\n&lt;/section&gt;\n\n// js\n&lt;script type=&quot;text/javascript&quot;&gt;\n  const sloganBg = {\n    index: 0,\n    indexMax: 29,\n    time: 0,\n    dom: document.querySelector('.section-03 .bg'),\n    auto(speed){\n      let change = setInterval( () =&gt; {\n        // 先移除上一帧的样式\n        this.dom.classList.remove(`bg-${this.index}`);\n\n        // 动态调整图片帧显示\n        this.index &lt; this.indexMax ? this.index++ : this.index = 0;\n        this.dom.classList.add(`bg-${this.index}`);\n\n        // 每运行10次动画周期后销毁定时器，进行垃圾回收后再重新创建\n        this.time += speed;\n        if ( this.time &gt; this.indexMax * speed * 10) {\n          clearInterval(change);\n          change = null;\n          this.time = 0;\n          this.auto(speed);\n        }\n      }, speed);\n    }\n  }\n  sloganBg.auto(100);\n&lt;/script&gt;\n</code></pre>\n<h3>方案四：使用css3逐帧动画</h3>\n<p>这个办法我是比较推荐的，实现成本并不高，写起来也很简单，体验又好。</p>\n<p>【推荐】★★★★☆</p>\n<p>【优点】简单，性能好，生成雪碧图，然后写个动画就完事。</p>\n<p>【弊端】部分古董设备不兼容，然后还有个问题，就是像demo里的这个素材，做成雪碧图贼他妈大（2.24MB，经过tinypin压缩后还是有640KB），所以素材太大的情况下，最好不要用这个办法来搞。</p>\n<pre><code class=\"language-javascript\">// css\n&lt;style&gt;\n.go {\n  background-image: url('../img/sprites.png');\n  background-repeat: no-repeat;\n  animation: go steps(29, end) 3s infinite;\n}\n@keyframes go {\n  100% {\n    background-position: -0 -8729px;\n}\n&lt;/style&gt;\n\n// html\n&lt;section class=&quot;section section-04&quot;&gt;\n  &lt;div class=&quot;img bg go&quot;&gt;&lt;/div&gt;\n&lt;/section&gt;\n</code></pre>\n<p>实现思路：</p>\n<p>1、把所有的帧素材都合并为一张雪碧图，减少http请求，通过animation的背景图移动来实现视觉上的切换。</p>\n<p>2、这里运用到了css3的animation-timing-function的steps，减少动画过程的代码编写</p>\n<p>3、结合第2点，因为steps(number, position)的两个参数，第一个参数是设定有多少帧，第二个参数是设置动画的连续方式，所以根据steps的特性，我们生成的雪碧图需要无间隔并且连贯（我生成的就是从上到下排序下来的）</p>\n<p>这里推荐一个在线工具：<a href=\"https://www.toptal.com/developers/css/sprite-generator\">快速生成雪碧图</a></p>\n<p>还有关于里面的steps的用法，可以参考张老师的文章：<a href=\"https://www.zhangxinxu.com/wordpress/2018/06/css3-animation-steps-step-start-end/\">CSS3 animation属性中的steps功能符深入介绍<br>\n</a></p>\n<h3>方案五：使用canvas逐帧绘制</h3>\n<p>终于来到一开头提到的canvas实现方案了。大话官网专题，我看了一下源代码，虽然代码被混淆，但还是可以看出，应该是通过引入插件来实现的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/04/4.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/04/5.jpg\" alt=\"\"></p>\n<p>我们自己写其实也不难，因为知道了本身的实现套路（有逐帧素材，然后通过逐帧逐帧去绘制渲染出来），那就可以着手编写代码了。</p>\n<p>【推荐】★★★★★</p>\n<p>【优点】canvas在性能上有天然的优势，对于高频率的更新渲染，用canvas重绘来实现效果更佳。</p>\n<p>【弊端】古董机对canvas的兼容性不太友好，如果可以抛弃这些古董用户的话，还是推荐这个方案！</p>\n<pre><code class=\"language-javascript\">// html\n&lt;section class=&quot;section section-05&quot;&gt;\n  &lt;div class=&quot;img&quot;&gt;&lt;/div&gt;\n&lt;/section&gt;\n\n// js\n&lt;script type=&quot;text/javascript&quot;&gt;\n  const sloganCanvas = {\n    index: 0,\n    indexMax: 29,\n    canvasWidth: 801,\n    canvasHeight: 301,\n    init(){\n      // 创建画布\n      const canvas = document.createElement('canvas');\n      canvas['width'] = this.canvasWidth;\n      canvas['height'] = this.canvasHeight;\n      document.querySelector('.section-05 .img').appendChild(canvas);\n\n      // 绘制内容\n      this.draw(this.index, canvas);\n    },\n    draw(index, canvas){\n      const context = canvas.getContext('2d');\n      const img = new Image();\n      img.onload = () =&gt; {\n        // 绘制前先清空画布\n        context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        // 然后再绘制当前帧\n        context.drawImage(img, 0, 0, this.canvasWidth, this.canvasHeight);\n\n        // 画完更换下一帧的索引\n        this.index &lt; this.indexMax ? this.index++ : this.index = 0;\n        setTimeout( () =&gt; {\n          this.draw(this.index, canvas);\n        }, 100);\n      }\n      img.src = `img/${this.index}.png`;\n    }\n  }\n  sloganCanvas.init();\n&lt;/script&gt;\n</code></pre>\n<p>实现思路：</p>\n<p>1、动态创建canvas，不要写死canvas的宽度和高度，实际需求如果要覆盖移动端，请动态计算尺寸后生成（官网专题是不做移动端了，移动端纯jpg图，感觉有点可惜）</p>\n<p>2、载入每帧的素材的时候，后续操作都要放在img的onload事件里执行</p>\n<p>3、每次进行绘制之前，记得先清空画布，否则会一直叠加绘制，就没法看了…</p>\n<p>4、通过setTimeout的延时回调控制无限循环动画的速度</p>\n<h2>最后</h2>\n<p>有几个方案我没有写，关于svg对这个需求的实现，暂时没有思路，我选择放弃，以后想到了再来补上！</p>\n<p>而视频和flash这些多媒体的展示方案，这里就略过了，处理成本对我来说还是比较高的，要配合设计的主视觉去输出优质的素材，我不太擅长…（所以这种方案可以考虑把活交给设计师…）</p>\n<p>最后放上demo地址：<a href=\"https://chengpeiquan.github.io/canvas-movie-jitter-effect/index.html\">电影抖屏效果demo</a></p>\n",
            "title": "电影故障抖动视觉效果实现：对大话手游愚人节专题的探究",
            "date_modified": "2020-04-20T23:47:00.000Z",
            "author": {
                "name": "pengzhixin",
                "url": "https://pengyumo.com"
            }
        },
        {
            "content_html": "<p>[[toc]]</p>\n<p>最近过年放假，加上突如其来的在家办公，时间显得有点充裕，突然就想写写什么东西，决定来聊一聊接口的设计。</p>\n<p>接口规范这个东西，网上看到的，大部分都是服务端同学之间针对开发层面的交流，当然也看到有一些前端同学在吐槽接口不好用。</p>\n<p>作为一个接口使用者，在日常业务中，的确遇到过很多结构设计随意、字段命名随意的接口（大部分是为了活动而临时设计），而通常这种接口也缺少对应的文档（因为赶工期），所以理解起来比较费时间，遇到架构设计不合理的情况时，也容易导致在业务的实现过程中，需要写很多冗余的代码来输出最终的数据。</p>\n<p>所以想从前端的角度，以一个接口消费者的身份来谈一谈如何设计一套比较合理的接口，本文主要分为两部分：“接口的基本数据格式”和“接口的业务数据格式”。</p>\n<p>本文的目的是想减少前后端对接过程中产生的沟通问题，还有优化一些可以避免的错误，甚至于你可以不提供接口文档，前端也能快速上手你的接口。</p>\n<h2>接口的基本数据格式</h2>\n<p>目前主流的数据返回格式都是以JSON的形式，JSON的字段是以 <code>{ key: value }</code> 的形式成对出现的。</p>\n<p>其中key是用来读取指定数据的标识，并且在同一个层级的数据里，是唯一的存在，而value就是这个key所对应的数据信息。</p>\n<p>例如：在一个公司里，你的工号就是你的key，并且这个工号是唯一的，只属于你，可以通过这个工号来找到你的信息，而value此时就对应了你的姓名、入职时间等员工信息。</p>\n<p>基本数据格式，是围绕JSON格式规范层面上来讲的。</p>\n<h3>关于key的规范要求</h3>\n<p>key是用来读取指定数据的标识，<strong>在JSON的格式规范中，统一用 双引号 套起来</strong>，前端读取的时候，会通过 <code>data['key']</code>  或者 <code>data.key</code> 的格式获取对应字段的数据。</p>\n<p>在实际的项目接入中，遇到的key在命名上问题不少，有的是缩写随意，有的是语义不明，有的是上下级重复命名，更有的是用拼音甚至是拼音缩写。</p>\n<p>我知道在赶工期的时候，服务端同学并不是那么乐意把时间投入到写文档上面，希望前端能够一看就知道接口怎么用，那么写好规范化的key，就能够减少很多理解上的偏差，而这只需要花费一丢丢时间，所谓磨刀不误砍柴工，性价比是非常高的！</p>\n<p>所以建议在定key的时候，遵循一些必要的规范：</p>\n<ul>\n<li><strong>语义化来命名key，并且遵循下划线命名法或者驼峰命名法</strong></li>\n</ul>\n<p>比如：定义一个用户名字段，推荐使用<code>userName</code>或者<code>user_name</code>作为key，而<code>username</code>则不建议使用，更不允许使用<code>data1</code>、<code>data2</code>这样毫无意义的命名方式。</p>\n<p>确定好一套命名法之后，这一套接口就需要遵循同一种书写风格，不要混搭使用。</p>\n<ul>\n<li><strong>包含“多个结果”的字段，注意名词的复数形式的使用</strong></li>\n</ul>\n<p>比如：多个标签使用<code>tags</code>而不是<code>tag</code>，多个图片使用<code>pictures</code>而不是<code>picture</code></p>\n<p>这里有一个默认的使用窍门：</p>\n<p>1、当value为普通数组时，使用“名词复数”的形式命名key</p>\n<p>2、当value为嵌套了JSON对象的数组时，使用<code>名词 + list结尾</code>的形式来命名key</p>\n<p>比如：</p>\n<pre><code class=\"language-json\">{\n  &quot;tags&quot;: [&quot;食物&quot;, &quot;粤菜&quot;, &quot;卤水&quot;],\n  &quot;memberList&quot;: [\n    {\n      &quot;uid&quot;: 111,\n      &quot;name&quot;: &quot;张三&quot;,\n      &quot;age&quot;: 22\n    },\n    {\n      &quot;uid&quot;: 222,\n      &quot;name&quot;: &quot;李四&quot;,\n      &quot;age&quot;: 27\n    }\n  ]\n}\n</code></pre>\n<ul>\n<li><strong>判断查询类的字段，注意动词的配合</strong></li>\n</ul>\n<p>通常这种情况代表会返回一个布尔值（true/false），常用的有以下几种：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">动词</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">is</td>\n<td style=\"text-align:center\">是否符合某个条件</td>\n<td style=\"text-align:center\">{ &quot;isLogined&quot;: true, &quot;isVip&quot;: true }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">has</td>\n<td style=\"text-align:center\">是否包含某类数据</td>\n<td style=\"text-align:center\">{ &quot;hasCoupon&quot;: true, &quot;hasAvatar&quot;: false }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">can</td>\n<td style=\"text-align:center\">是否能够进行某个操作</td>\n<td style=\"text-align:center\">{ &quot;canPublish&quot;: false }</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>使用合理的缩写</strong></li>\n</ul>\n<p>缩写是为了提高开发时的书写效率，但是也要遵循缩写规范，或者仅使用普遍认知的缩写方式，不要自己创造一些只有自己看得懂的缩写方式。</p>\n<p>比如：等级<code>level</code>使用缩写<code>lv</code>，<code>message</code>使用缩写<code>msg</code>，<code>error</code>使用缩写<code>err</code>，<code>user id</code>使用缩写<code>uid</code>，都是允许的，但是<code>user name</code>缩写成<code>un</code>就会一脸懵逼！！！</p>\n<ul>\n<li><strong>避免使用重复的key</strong></li>\n</ul>\n<p>在同一级的关系里，key是唯一，如果有重复，后添加的会覆盖之前添加的。</p>\n<p>比如：已经有了一个<code>{ &quot;name&quot;: &quot;张三&quot; }</code>的情况下，你继续添加一个<code>{ &quot;name&quot;: &quot;李四&quot; }</code>，那最终读取name字段的时候，获取到的只有“李四”。</p>\n<p>不同层级允许使用相同的key命名，但是，容易造成bug……（我是真的遇到过这样的接口！）</p>\n<p>我举一个<strong>很恶心的例子（请不要这样写）</strong>，比如不同层级都使用了“data”作为key：</p>\n<pre><code class=\"language-json\">{\n  &quot;code&quot;: 200,\n  &quot;data&quot;: {\n    &quot;category&quot;: &quot;news&quot;,\n    &quot;data&quot;: [\n      {\n        &quot;subject&quot;: &quot;This is a subject.&quot;,\n        &quot;content&quot;: &quot;This is a content.&quot;\n      },\n      {\n        &quot;subject&quot;: &quot;This is another subject.&quot;,\n        &quot;content&quot;: &quot;This is another content.&quot;\n      }\n    ]\n  }\n}\n</code></pre>\n<p>假设前端采用axios发起的ajax请求，那么返回数据的时候，本身获取JSON需要用到<code>response.data</code>就包含了一个data，如果要获取第一个subject，则需要使用<code>response.data.data.data[0].subject</code>连续的写上3个data，非常容易出错！！！</p>\n<p>以上部分就是对key的规范约束，如果能注意这些问题的话，我相信就算你来不及写接口文档，前端同学一看数据格式也能马上明白你的接口各个字段的含义和用法。</p>\n<h3>关于value的规范要求</h3>\n<p>在JSON规范中，value对应六种不同的数据类型，不同类型的表达形式也有所区分，具体如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">特征</th>\n<th style=\"text-align:center\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">String 字符串</td>\n<td style=\"text-align:center\">value套在双引号中</td>\n<td style=\"text-align:center\">{ &quot;name&quot;: &quot;张三&quot; }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Number 数字</td>\n<td style=\"text-align:center\">value为整数或者是浮点数</td>\n<td style=\"text-align:center\">{ &quot;age&quot;: 18, &quot;weight&quot;: 84.83 }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Boolean 布尔值</td>\n<td style=\"text-align:center\">value为true或者是false</td>\n<td style=\"text-align:center\">{ &quot;isLogined&quot;: true, &quot;isVip&quot;: false }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Array 数组</td>\n<td style=\"text-align:center\">value套在方括号中</td>\n<td style=\"text-align:center\">{ &quot;tags&quot;: [&quot;中餐&quot;, &quot;粤菜&quot;, &quot;卤水&quot;, &quot;荤菜&quot;] }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object 对象</td>\n<td style=\"text-align:center\">value套在花括号中</td>\n<td style=\"text-align:center\">{ &quot;userInfo&quot;: { &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18 } }</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Null 空类型</td>\n<td style=\"text-align:center\">value为null</td>\n<td style=\"text-align:center\">{ &quot;girlFriend&quot;: null }</td>\n</tr>\n</tbody>\n</table>\n<p>那么什么情况应该用什么类型的数据呢？我们一个一个类型来解析一下：</p>\n<ul>\n<li><strong>String 字符串</strong></li>\n</ul>\n<p>最常见的数据格式，理论上所有类型都可以用string的形式返回，然后再转换解决（虽然可以，但是没必要…）</p>\n<p>一般用于文本展示，url链接、图像地址、或者一些要渲染成html代码的源码部分，我们可以选择字符串传输。</p>\n<p>另外对于以下其他类型都不适合的场景，也都可以选择字符串来传输，<strong>不过如果能用对应类型的数据，最好还是用他们应该用的类型。</strong></p>\n<ul>\n<li><strong>Number 数字</strong></li>\n</ul>\n<p>当你需要返回的值，只用一个数值即可表达的时候，就选择用Number类型。</p>\n<p>常用的有“时间戳、用户uid、年龄、价格、页码、物品数量”等场景。</p>\n<ul>\n<li><strong>Boolean 布尔值</strong></li>\n</ul>\n<p>当你需要对一个判断条件返回结果的时候，就选择用Boolean类型。</p>\n<p>常用的场景有“判断用户是否已登录、判断用户是否vip会员、判断用户是否有优惠资格等等”。</p>\n<p>误区：之前遇到有的服务端不知道是什么原因，在应该返回<code>false</code>的时候，返回的是<code>'false'</code>，瞬间从Boolean变成了String… <strong>从假变成了真！！！</strong> 这是两个完全不一样的数据！</p>\n<ul>\n<li><strong>Array 数组</strong></li>\n</ul>\n<p>当你需要返回“种类一样”的“多个结果”的时候，由于key的唯一性限制，这个时候就可以选择用Array类型。</p>\n<p>比如：返回一个相册图集的图片信息，只需要单纯返回一堆url，那么用数组可是非常的方便。</p>\n<pre><code class=\"language-json\">{\n  &quot;pictures&quot;: [\n    &quot;https://example.com/111.jpg&quot;,\n    &quot;https://example.com/222.jpg&quot;,\n    &quot;https://example.com/333.jpg&quot;\n  ]\n}\n</code></pre>\n<p>比如：返回一个文章列表，所有的文章结构其实是一样的，那么就可以用包含了对象的数组来输出你的value。</p>\n<pre><code class=\"language-json\">{\n  &quot;articleList&quot;: [\n    {\n      &quot;id&quot;: 111,\n      &quot;subject&quot;: &quot;This is a subject.&quot;,\n      &quot;author&quot;: &quot;Petter&quot;,\n      &quot;date&quot;: &quot;2020-01-01 11:11&quot;,\n      &quot;content&quot;: &quot;This is a content.&quot;\n    },\n    {\n      &quot;id&quot;: 222,\n      &quot;subject&quot;: &quot;This is another subject.&quot;,\n      &quot;author&quot;: &quot;Mary&quot;,\n      &quot;date&quot;: &quot;2020-01-02 12:12&quot;,\n      &quot;content&quot;: &quot;This is another content.&quot;\n    }\n  ]\n}\n</code></pre>\n<ul>\n<li><strong>Object 对象</strong></li>\n</ul>\n<p>JSON本身是一个Object，但是支持嵌套Object，当你需要对一个字段返回多个相关信息的时候，不应该零散的一个一个单独返回，而是应该集合到一个Object里一起返回。</p>\n<p>比如：从接口把“张三”的注册资料传下来，他的uid、昵称、头像等等，都属于相关信息，所以可以按下面这样，返回一个Object嵌套到JSON里。</p>\n<pre><code class=\"language-json\">{\n  &quot;userInfo&quot;: {\n    &quot;uid&quot;: 111,\n    &quot;name&quot;: &quot;张三&quot;,\n    &quot;age&quot;: 24,\n    &quot;isVip&quot;: true\n  }\n}\n</code></pre>\n<ul>\n<li><strong>Null 空类型</strong></li>\n</ul>\n<p>空类型一般不会单独作为一个字段的值出现在接口中，更多时候是用来代替某个字段原本应该出现但缺失了的值（也就是这个字段有可能有，有可能没有，出现没有就是null）。</p>\n<p>当数据为空的时候，按照目前约定俗成的做法，基本上有以下三种处理方案（需要前后端同学提前约定选择）：</p>\n<p><strong>处理方案一：接口返回null</strong></p>\n<p>当一条记录不存在的时候，接口可以返回一个null值给前端，前端判断为null的时候，就知道这条数据是没有的。</p>\n<p><strong>处理方案二：接口不返回该字段</strong></p>\n<p>目前运用比较广泛的处理方案就是直接不返回该字段，前端读取到这个字段的时候会返回undefined，前端同学在需要用到这个字段的时候，可以灵活处理数据：</p>\n<p>直接使用该字段的时候，如果字段不存在，可以预设一个默认值。</p>\n<pre><code class=\"language-javascript\">const KEY = data.key || 'key';\n</code></pre>\n<p>涉及需要二次处理该字段数据的时候，则加上一个判断</p>\n<pre><code class=\"language-javascript\">if ( 'key' in data ) {\n  console.log(data.key);\n}\n</code></pre>\n<p><strong>处理方案三：接口返回该字段类型的默认“空值”</strong></p>\n<p>这也是一个运用的比较广泛的方法，这里的“空值”是指，根据原来设定的数据类型，返回一个初始默认值，比如：</p>\n<p>如果原来是个字符串，那么“空值”就应该是<code>''</code></p>\n<p>如果原来是个数组，那么“空值”就应该是<code>[]</code></p>\n<p>如果原来是个对象，那么“空值”就应该是<code>{}</code></p>\n<p>如果原来是个数字，“空值”则需要根据业务场景来处理，比如“好友数”的默认值可以是<code>0</code>，但是页码的默认值则需要为<code>1</code></p>\n<p>布尔值也是需要根据业务场景设定默认值，绝大部分场景都需要默认为<code>false</code>，比如“是否vip”，对于大部分用户来说，初始默认值肯定是设置为<code>false</code>为佳。</p>\n<h2>接口的业务数据格式</h2>\n<p>讲完基础格式，想聊一聊业务方面的数据格式，顾名思义，是指在业务层面上，虽然符合基本规范，但是在使用上可能会存在的一些人为导致的不合理的地方，从而影响到代码的可复用性、灵活程度等等。</p>\n<h3>不同接口的“相同数据”</h3>\n<p>对于一个网站或者app，通常每个不同类型的页面，都会对应不同的接口用以支持需要的数据渲染，但在落实业务的时候，往往会发现，常常出现“不同的页面”里包含着“相同结构的数据”的情况。</p>\n<p>以腾讯新闻为例，它包含了“首页推荐”、“搜索结果页”、“专题聚合页”、“热点聚合页”等不同页面，但这些页面都包含了相同的模块 —— “新闻列表”。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chengpeiquan/assets-storage/img/2020/02/20210216230213.jpg\" alt=\"新闻列表\"></p>\n<p>可以看出，“新闻列表”这个模块，每个新闻基本上都是包含了“新闻标题”、“新闻来源”、“评论数”、“发布时间”以及“缩略图（1-3张）”这几个数据信息，那么在指定接口格式的时候，这一部分最好就要统一起来：</p>\n<pre><code class=\"language-json\">{\n  &quot;newsList&quot;: [\n    {\n      &quot;newsId&quot;: 111,\n      &quot;subject&quot;: &quot;这是一个新闻标题&quot;,\n      &quot;source&quot;: &quot;央视新闻&quot;,\n      &quot;commentCount&quot;: 1234,\n      &quot;createTime&quot;: 1581850220403,\n      &quot;thumbs&quot;: [\n        &quot;https://example.com/111.jpg&quot;,\n        &quot;https://example.com/222.jpg&quot;,\n        &quot;https://example.com/333.jpg&quot;\n      ]\n    },\n    {\n      &quot;newsId&quot;: 222,\n      &quot;subject&quot;: &quot;这也是一个新闻标题&quot;,\n      &quot;source&quot;: &quot;人民日报&quot;,\n      &quot;commentCount&quot;: 2333,\n      &quot;createTime&quot;: 1581850528657,\n      &quot;thumbs&quot;: [\n        &quot;https://example.com/444.jpg&quot;\n      ]\n    }\n  ]\n}\n</code></pre>\n<p>然后再根据每个接口的需要，添加自己本身的特色数据。</p>\n<p>这样做的好处是，不管是搜索页的“搜索结果”、推荐页的“猜你喜欢”、专题页的“热点聚合”或者其他哪个页面的数据，对于前端同学来说，它本质都只是一个结构相同的新闻列表，统一字段名和数据结构，能有效降低维护过程中的认知成本、对接成本，并且可以封装成公共方法来处理数据调用，减少差错发生。</p>\n<h3>业务状态码与反馈信息</h3>\n<p>在http状态码的基础上，接口也都会有自己的一套业务状态码规则，用于反馈接口交互过程中的合法性。</p>\n<p>那什么情况下才需要使用状态码？是不是能考虑到的错误都需要提供错误码给前端判断呢？</p>\n<p>答案是否定的，状态码过多容易造成维护成本的增加，建议只在一些前端完全无法识别的错误场景才提供错误码。</p>\n<ul>\n<li><strong>不需要接口反馈状态码的情况</strong></li>\n</ul>\n<p>前端可以识别的错误场景可以由前端判断解决，无需接口来处理反馈，简单来说，基于常识性的错误，应该都属于前端可掌握的判断范围。</p>\n<p>拿文章列表来举例，文章列表的url通常包含着页码信息，用户可以自定义修改页码访问不同的分页数据，有时候因为页码错误的原因，导致文章列表为空，这种情况，按我们上面讲过的方法，此时数据应该是</p>\n<pre><code class=\"language-json\">{\n  &quot;page&quot;: 10,\n  &quot;articleList&quot;: []\n}\n</code></pre>\n<p>这种情况，实际上前端只需要判断一下数组的长度是否为0，以及页码大小，即可立即知道列表是否为空，以及为什么会列表为空：</p>\n<p><strong>页码小于1表示页码错误</strong></p>\n<p><strong>页码等于1表示当前真的还没有数据（一般出现在新创建的分类列表）</strong></p>\n<p><strong>页码大于1表示超过最大页数</strong></p>\n<p>直接由前端判断后告知用户页码错误情况即可，无需服务端再处理一套页码错误反馈逻辑。</p>\n<ul>\n<li><strong>需要接口反馈状态码的情况</strong></li>\n</ul>\n<p>通俗点来说就是，前端同学：“我怎么知道这东西是真是假”，必须通过服务端确认后才可以得出结论的场景。</p>\n<p>还是拿文章列表来举例，比如网站有很多文章分类目录，每个分类对应一个列表，前端在提交请求的时候，是无法知道当前的分类id是否存在，这种情况下，就需要由服务端来反馈错误信息：</p>\n<pre><code class=\"language-json\">{\n  &quot;code&quot;: 404,\n  &quot;message&quot;: &quot;文章分类不存在&quot;\n}\n</code></pre>\n<ul>\n<li><strong>反馈信息尽量由接口返回</strong></li>\n</ul>\n<p>虽然在遇到错误场景的时候，接口可以只返回status code，前端根据接口文档的code说明，把提示语写死在页面上，但整个工程的灵活程度就大大降低，每次有所调整，前后端都需要进行修改。</p>\n<p>建议接口在返回code的时候同时返回message，前端在弹出Toast的时候，文案直接使用服务端返回的message来灵活反馈给用户。</p>\n<p>这样不管是修改提示文案，还是新增了新的code，都无需重新修改页面，容错率高。</p>\n<ul>\n<li><strong>状态码不一定是数字</strong></li>\n</ul>\n<p>目前来说，绝大部分接口在定义status code的时候，都是使用数字来作为状态码。</p>\n<p>之前在参与开发公司的discuz业务时，发现dz的mobile api状态码就很有趣，用的是英文keyword来表达：</p>\n<pre><code class=\"language-json\">{\n  &quot;Message&quot;: {\n    &quot;messageval&quot;: &quot;word_banned&quot;,\n    &quot;messagestr&quot;: &quot;抱歉，您填写的内容包含敏感信息而无法提交&quot;\n  }\n}\n</code></pre>\n<pre><code class=\"language-json\">{\n  &quot;Message&quot;: {\n    &quot;messageval&quot;: &quot;thread_nonexistence&quot;,\n    &quot;messagestr&quot;: &quot;抱歉，指定的主题不存在或已被删除或正在被审核&quot;\n  }\n}\n</code></pre>\n<p>因为discuz的系统非常庞大，状态码肯定非常多，如果用数字，不仅容易重复，而且拿到一个数字还不一定能马上知道是什么意思，得去查文档。</p>\n<p>而通过这种keyword的方式来表达状态码，看到文案就能知道出了什么情况了，非常巧妙！</p>\n<p>分割线来个结束语：</p>\n<p>以上呢，就是这个假期里，目前对接口业务的一些思考和小结，欢迎点评和讨论！</p>\n",
            "title": "接口设计：从前端开发的角度谈一谈接口规范",
            "date_modified": "2020-02-17T01:01:00.000Z",
            "author": {
                "name": "pengzhixin",
                "url": "https://pengyumo.com"
            }
        }
    ]
}